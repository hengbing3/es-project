{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1731614040905609218",
        "title": "如何开发代码生成器平台？分享下思路",
        "description": null,
        "content": "大家好，我是鱼皮，我的新项目 [《鱼籽 - 定制化代码生成项目》](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247551946&idx=1&sn=7ee030c1be17de5ec94565f8976ef69a&chksm=e9c2ec3ddeb5652b0b2c15075d7d01e7286fdcf3f6ee6dcb3d720e44a76dc40bde5998b49a70&token=254196216&lang=zh_CN#rd) 系列教程正式开始！\n\n本次项目依然是从 0 到 1 带大家开发，会遵循企业项目开发的标准流程：需求分析 => 技术选型 => 项目设计 => 项目初始化 => Demo 编写 => 前后端开发实现 => 测试验证 => 部署上线，带大家一步步完成整个项目。\n\n本篇文章作为该项目的第一期教程，公开免费，给大家分享整个项目的介绍和背景、项目的技术选型、项目设计、业务流程、大致的实现思路和要解决的关键问题等，内容会比较轻松。\n\n对于有能力的同学，学到了本文的思路，哪怕后面不跟着我的教程学习，应该也是能完成项目的，有一定的参考价值~\n\n朋友们，准备开启新项目的学习之旅吧！\n\n> 第一期视频教程免费：https://www.bilibili.com/video/BV1ie411Q7AV\n>\n> 文末有加入项目学习的方式\n\n![](https://pic.yupi.icu/1/image-20231105135843022.png)\n\n\n\n## 项目介绍\n\n这次要带大家做的是一个非常有趣又实用的项目，基于 React + Spring Boot + Vert.x 响应式编程的 **定制化代码生成项目** 。\n\n\n\n注意！这次的项目会很特别，听起来是一个项目，但其实是循序渐进的 **3 个项目** ！\n\n\n\n![](https://pic.yupi.icu/1/1698933854908-e93e1a08-0d82-4ce2-a020-00522bb10403-20231105134745089.png)\n\n\n\n完整项目分为 3 个阶段：\n\n1）第一阶段，我会带大家制作属于自己的 `本地代码生成器` ，是一个 **基于命令行的脚手架** ，能够根据用户的交互式输入快速生成特定代码。\n\n\n\n![](https://pic.yupi.icu/1/1698933854885-965d0281-ecfc-4940-824a-2da48eb5b8ad-20231105134745113.png)\n\n\n\n网上绝大多数的代码生成器教程，也只是讲到这个阶段。\n\n\n\n2）第二阶段，让我们上升一个层次，带大家开发 `制作代码生成器的工具` 。比如你有一段常用的项目代码，使用该工具，可以快速把项目代码制作为代码生成器，将是提高工作效率的大杀器！\n\n\n\n3）第三阶段，让我们再上升一个层次，带大家开发 `在线代码生成器平台` ！你可以在平台上制作发布自己的代码生成器，还可以在线使用别人的代码生成器，甚至可以共享协作！\n\n\n\n![](https://pic.yupi.icu/1/1698933854913-c0593377-66c7-4fad-b0de-559d83f28a4e-20231105134745236.png)\n\n\n\n之所以要分为 3 个阶段，一方面是因为项目是比较庞大的，拆分后学习会更轻松；另一方面是不同阶段的难度不同，大家可以根据自己的学习进度和时间独立学习。\n\n\n\n比如即使你什么框架都没学过，也可以完成第一阶段；而如果你学过开发框架，可以完成第二阶段；如果你想学习更多高级知识和优化技巧，再去看第三阶段。够贴心吧~\n\n\n\n## 项目背景\n\n为什么要带大家做这个项目呢？\n\n这也是一个需求分析的过程，我主要考虑的是：学习意义、解决的问题、实际应用三个方面。\n\n\n\n### 学习意义\n\n1）教程资料少：网上虽然有现成的项目模板，但基本都是别人封装好的，只能按作者的要求生成，并且缺少项目教程；而本项目不仅带大家做自己的代码生成器，还会 **进 2 步** 扩展，打造制作自定义代码生成器的工具和平台。\n\n2）新颖且亮眼：别人写代码，而你做生产代码的脚手架、工具和平台来提高研发效能，降维打击。\n\n3）能学到东西：不再是增删改查的项目，而是包含了大量的实际业务场景、系统设计和解决方案。\n\n4）有区分度：区别于传统 Web 应用，项目涉及命令行应用、响应式编程、性能优化的入门及实战，给你的简历增加竞争力。\n\n\n\n### 解决的问题\n\n1）代码生成器本身的作用就是自动生成常见、重复性的代码片段，**解决重复编码、效率低下的问题** 。\n\n2）虽然网上有很多代码生成器，但都是别人制作封装好的，很多时候还是 **无法满足实际开发的定制化需求** （比如要在每个类上增加特定的注解和注释）。这也是为什么明明有代码生成器，很多开发者还是会抱怨自己的工作总是复制粘贴、编写重复的代码、天天 CRUD（增删改查）。如果能够有一个工具帮助开发者快速定制属于自己的代码生成器，那么将进一步提高开发效率。\n\n3）在团队开发中，要生成的代码可能是需要频繁变化和持续更新维护的。如果有一个线上平台来维护多个不同的代码生成器，支持在线编辑和共享生成器，在提高开发效率的同时、将有利于协作共建，打造更高质量的代码生成器。\n\n\n\n### 实际应用\n\n举例一些代码生成的实际应用场景，我们将通过本项目进行解决：\n\n1）经常做算法题目的同学，可能需要一套 Java ACM 代码输入模板，能够支持多种不同输入模式（比如单次读取和循环）。\n\n2）经常开发新项目的同学，可能需要一套初始化项目模板代码，比如一键生成 Controller 层代码（替换其中的对象）、整合 Redis 和 MySQL 依赖等。\n\n3）甚至可以制作项目 “换皮” 工具，支持一键给网络热门项目换皮（比如替换项目的名称、Logo 等）\n\n\n\n## 项目特点\n\n本次项目，会和之前的 [鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 一样，鱼皮依然会 **从 0 到 1 全程直播无剪辑** 地带大家开发完成项目，需求分析 => 技术选型 => 项目设计 => 项目初始化 => Demo 编写 => 前后端开发实现等，每个环节我都 **从理论到实践** 给大家讲的明明白白、每个细节都不放过！\n\n\n\n鱼皮的实战项目系列还会提供以下服务：\n\n- 详细的直播笔记\n- 完整的项目源码\n- 答疑解惑\n- 专属项目交流群\n- ⭐️ 现成的简历写法（直接写满简历）\n- ⭐️ 项目的扩展思路（拉开和其他人的差距）\n- ⭐️ 项目相关面试题、题解和真实面经（提前准备，面试不懵逼）\n- ⭐️ Java 后端万用项目模板（快速创建项目）\n\n\n\n而且这次的新项目，鱼皮会尝试一种新的模式：\n\n\n\n1）代码全部开源：开源最大的好处是协作共建。一方面让项目持续发展、获取更多扩展点给大家学习参考；另一方面所有学完项目的同学都能参与项目共建、成为项目贡献者给简历加分，星球鱼友们在贡献代码时可以和大家交流，并且更容易参与贡献，我们争取一起做个很牛的项目！\n\n\n\n从 0 开始跟学 1 个开源项目，然后直接成为贡献者，这绝对是一个非常刺激的体验~\n\n\n\n2）讲解方式升级：会在原有直播带做项目的基础上，额外编写一套 **文字教程** 。兼容喜欢看文章学习的同学，并且便于大家复习~\n\n\n\n虽然这种方式要花比原来多至少 1 倍的时间，但我还是希望能给大家更好的学习体验，毕竟看着大家拿到 offer，我也开心哈哈：\n\n\n\n![](https://pic.yupi.icu/1/1698933854909-d181426f-df5f-40f9-981e-9692baa243d8-20231105134745316.png)\n\n\n\n## 需求分析\n\n其实上面已经带大家了解了项目的基本信息、项目的意义和价值。在需求分析阶段，我们通常还要进行一些调研工作，帮助我们明确需求、为后面的设计做好充分的准备。\n\n\n\n### 调研\n\n网上有一些代码生成器项目，比如前端 [Ant Design Pro](https://pro.ant.design/zh-CN) 中后台项目脚手架，能够让用户交互式地创建指定的项目；还有后端 MyBatis X 插件，能够让用户通过界面来创建 CRUD 重复代码。但这些项目都是开发者提前制作好了代码生成器，然后让你 **根据他们设置好的规则** 生成代码（或者拉取特定位置的代码），生成后的代码通常还要再自己二次修改，不够灵活。\n\n还有很多所谓的代码生成项目，其实本质上是一个现成的项目模板，让你通过编写对应的配置文件来使用项目，或者还是基于预设的程序来生成特定代码。比如 [编程导航知识星球](https://yuyuanweb.feishu.cn/wiki/VC1qwmX9diCBK3kidyec74vFnde) 的 Spring Boot 万用项目模板，或者网上很多知名的开源管理系统。\n\n这和我们要做的事情不同，我们的目标是升级一个层次！打造一个帮助大家快速制作代码生成器的工具，也就是 “造轮子的轮子”。\n\n然后再升级一个层次！允许用户像发布应用一样，在平台上发布和管理代码生成器，便于共享和协作！\n\n\n\n## 技术选型\n\n暂定的核心技术如下，实际开发中还会引入新技术\n\n\n\n### 前端\n\n- React 开发框架 + 组件库 + 代码编辑器\n- 前端工程化：ESLint + Prettier + TypeScript\n\n\n\n### 后端\n\n- Java Spring Boot + MySQL + MyBatis Plus（万用后端模板）\n- Java 命令行应用开发\n- FreeMarker 模板引擎\n- Vert.x 响应式编程\n- Caffeine + Redis 多级缓存\n- 分布式任务调度系统\n- 多种设计模式\n- 多种系统设计的巧思\n- 对象存储\n\n\n\n### 学习重点\n\n其中：Java 命令行应用开发、FreeMarker 模板引擎、Vert.x 响应式编程、设计模式、系统设计的巧思、分布式任务调度系统都是本项目的学习重点，也是校招简历上很少有同学提到的知识实践，学完后能够大大增加简历的区分度！\n\n比如 Vert.x 框架，并发连接处理能力吊打 Spring 几条街！\n\nWeb Framework Benchmarks 性能对比网站：https://www.techempower.com/benchmarks/#section=data-r21&test=composite\n\n![](https://pic.yupi.icu/1/1698810692479-1ab9f790-eebb-47e5-84fb-1db6775c03bc-20231105134745381.png)\n\n![](https://pic.yupi.icu/1/1698810756154-01c4352e-aa62-4b99-b5ec-45479adb0e69-20231105134745414.png)\n\n\n\n## 项目设计\n\n首先我们要理解代码生成的核心原理。\n\n\n\n### 代码生成器的核心原理\n\n一句话：参数 + 模板文件 = 生成的完整代码\n\n\n\n比如参数：\n\n```java\n作者 = 鱼皮\n```\n\n\n\n模板文件代码：\n\n```java\n-----------\n我是 ${作者}\n-----------\n```\n\n\n\n将参数注入到模板文件中，得到生成的完整代码：\n\n```java\n-----------\n我是 鱼皮\n-----------\n```\n\n\n\n如果想要使用这套模板生成其他的代码，只需要改变参数的值即可，而不需要改变模板文件。\n\n理解了代码生成器的核心原理后，就可以开始思考项目的设计实现方案了。\n\n\n\n------\n\n\n\n项目总共分为 3 个阶段，让我们分别来进行设计。\n\n\n\n### 第一阶段 - 本地代码生成器\n\n这个阶段，我们的目标是做一个本地（离线）的代码生成器，实现一个简易的 Java ACM 模板项目的定制化生成。\n\n本阶段不依赖复杂的开发框架，**没学过任何开发框架也能学习。**\n\n\n\n#### 业务流程\n\n1）准备用于制作代码生成器的原始代码（比如 Java ACM 模板项目），用于后续生成\n\n2）开发者基于原始代码，设置参数、编写动态模板\n\n3）制作可交互的命令行工具，支持用户输入参数，得到代码生成器 jar 包\n\n4）使用者得到代码生成器 jar 包，执行程序并输入参数，从而生成完整代码\n\n\n\n流程图如下：\n\n![](https://pic.yupi.icu/1/1698930303648-d82309e8-bbde-43dd-adb2-9d0c647e1e40-20231105134745441.jpeg)\n\n\n\n#### 实现思路\n\n1）先根据本地项目，扫描文件树，实现同样的静态代码生成\n\n2）根据本地的项目，预设部分动态参数、编写模板文件，能够传入配置对象进行生成\n\n3）制作可交互的命令行工具，接受用户输入的参数，并动态生成代码\n\n4）封装制作代码生成器 jar 包文件，并简化使用命令\n\n\n\n#### 关键问题\n\n1）如何根据一套项目文件，完整地生成同样一套项目？\n\n2）如何编写动态模板文件？怎么根据模板和参数生成代码？\n\n3）如何制作命令行工具？如何交互式接受用户的输入？\n\n4）怎么将命令行工具制作为 jar 包？怎么简化使用命令？\n\n\n\n### 第二阶段 - 代码生成器制作工具\n\n这个阶段，我们的目标是做一个本地的代码生成器制作工具，能够快速将一个项目制作为可以动态定制部分内容的代码生成器。并且以一个 Spring Boot 初始化项目模板（Maven 项目）为例，演示如何根据自己的需要动态生成 Java 后端初始化项目。\n\n本阶段的学习需要一定的 Spring Boot 开发知识，最好先完成 [星球的其他项目](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) ，推荐用户中心和聚合搜索。\n\n\n\n#### 业务流程\n\n1）准备用于制作代码生成器的原始代码（比如 Spring Boot 项目模板），用于后续生成\n\n2）开发者基于原始代码，**使用代码生成器制作工具**，来快速设置参数、生成动态模板\n\n3）**使用代码生成器制作工具**，动态生成代码生成器 jar 包\n\n4）使用者得到代码生成器 jar 包，执行程序并输入参数，从而生成完整代码\n\n\n\n相比第一阶段的业务流程，本阶段完成后，可以直接使用代码生成器制作工具来快速将固定的项目代码改造为可定制生成的动态模板，并自动生成命令行工具 jar 包。\n\n\n\n流程图如下：\n\n![](https://pic.yupi.icu/1/1698843403252-3ee97aaa-c20e-4922-ae0e-1195b44e1c3b-20231105134745633.jpeg)\n\n\n\n#### 实现思路\n\n1）使用独立空间来存储管理要生成的原始文件、动态模板文件等\n\n2）使用配置文件来记录要生成的参数和模板文件信息、自定义配置等 **元信息**\n\n3）代码生成器制作工具需要有多种可单独或组合使用的功能，比如从原始文件中抽取参数、动态生成命令行工具、打 jar 包等\n\n\n\n#### 关键问题\n\n1）如何使用配置文件来记录参数和模板文件信息？何种结构？\n\n2）怎么能够提高代码生成器的制作效率？工具应该提供哪些能力？\n\n3）如何从原始文件中抽取参数？有哪些类型的参数？有哪些抽取规则？比如布尔类型参数（是否生成）、字符串类型参数（生成指定的值）等\n\n![](https://pic.yupi.icu/1/1698930808644-1dc4e66a-0ea5-4128-aed3-73b828330666-20231105134745659.png)\n\n4）如何动态生成配置类？如何动态生成命令行工具？如何动态打 jar 包？\n\n\n\n### 第三阶段 - 在线代码生成器平台\n\n经过前两个阶段，我们已经能够使用本地的代码生成器制作工具来快速定制自己的代码生成器了。\n\n但如果我们想和团队其他同学共同维护代码生成器、或者使用其他人的代码生成器，通过本地文件互传的方式肯定就很麻烦了。\n\n所以本阶段我们要打造一个在线代码生成器平台，可以理解为代码生成器的 **应用市场**。所有人都能发布、使用、甚至是在线制作自己的代码生成器！\n\n本阶段我们的终极目标是，在平台上制作和发布项目 “换皮” 工具，帮助小伙伴们一键给网络热门项目换皮！\n\n![](https://pic.yupi.icu/1/1698844599236-cdc91554-bcfe-4028-84b6-2dffb082ed94-20231105134745675.png)\n\n\n\n#### 业务流程\n\n1）获取用于制作代码生成器的原始代码（手动准备或者远程拉取代码）\n\n2）开发者基于原始代码，使用 **在线代码生成器制作工具**，来快速制作代码生成器\n\n3）开发者发布代码生成器至平台\n\n4）使用者在平台上搜索代码生成器，支持在线使用或者下载离线 jar 包（甚至还可以支持接口调用）\n\n\n\n完整业务流程图如下：\n\n![](https://pic.yupi.icu/1/1698931262679-a16ecd8d-4d4c-4c8d-bdcc-eab7554ab10c-20231105134745839.jpeg)\n\n\n\n\n\n#### 实现思路\n\n1）使用 Web 开发框架实现代码生成器信息的增删改查\n\n2）将本地的配置和文件 **上云**，存储到数据库、对象存储等云服务。\n\n3）通过可视化界面来操作第二阶段的代码生成器制作工具，复用阶段二的成果。\n\n\n\n#### 关键问题\n\n1）怎么在云上存储管理代码生成器？\n\n2）如何通过前端开发，提高代码生成器的制作效率？\n\n3）如何通过后端优化，提高代码生成器的制作性能？\n\n4）如何保证代码生成器的存储空间不超限、如何优化存储？\n\n\n\n## 新建代码仓库\n\n先搭建个代码仓库，激励一下自己。\n\n鱼皮新建的官方代码仓库：https://github.com/liyupi/yuzi-generator ，点 star 的都是精神股东~\n\n\n\n## 最后\n\n以上就是本期教程，相信大家看了上面的设计思路和关键问题后，已经对这个项目充满期待、迫不及待地想要解决这些问题了吧~\n\n那就做好准备，让我们打起百分百的精神开启正式的项目学习~ 上面的问题，鱼皮都会一一带着大家解决！\n\n新项目启动，限时发放大额优惠 \uD83E\uDDE7，名额有限！欢迎小伙伴们加入学习，快速提升项目实战能力 \uD83D\uDC4F\uD83C\uDFFB ",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/Ur2XYYC8-640.png",
        "language": null,
        "viewNum": 1,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-04T09:58:53.000+00:00",
        "updateTime": "2023-12-04T13:28:34.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 2985,
          "coin": 170,
          "followeeNum": 1263,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-12-02T07:33:16.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1731152357468794881",
        "title": "MacBook电脑如何更高效的使用鼠标",
        "description": "MacBook电脑如何更高效的使用鼠标",
        "content": "作为一名使用两年多的mac用户已经十分依赖mac电脑开发带来的舒适感，在最开始刚换mac的时候就被它好用的触控板迷住了，以至于后面很长一段时间都没有使用鼠标，但是渐渐发现在我需要处理很多任务或者很忙的时候开了很多应用页面只使用触控板其实还是很痛苦的，比如你需要4个指头你滑动触控板去切换页面，切换的时间久了手指会被摩擦的很不舒服，尤其是在手特别干的时候，当天气热的时候又容易出汗，而且频繁的去切换自己手势虽然短时间内没什么，但是时间一长的话就感觉大脑有点麻木哈哈。\n\n经过很长时间的挣扎我还是决定使用鼠标，毕竟点一点手指就能完成的操作更丝滑不是吗？\n\n那么问题来了，我该如何用一个最普通的鼠标(也想过去买一个功能比较多的鼠标，但是总是有一种怪怪的感觉，所以还是放弃这个想法了)去完成伟大的妙控板可以完成的事呢？而且还不费力呢？\n\n思前想后只有一个办法，没错那就是手势，我们可以制定任何我们符合我们日常生活的手势去完成这些操作。\n\n想法有了，现在就差一款软件了（mac为了卖自己的鼠标当然不会这么便利，做的就是抵制资本哈哈），经过多款软件对比，最后终于找到了最合适mac的一款软件\n\n![image-20231203105249688](https://pic-es.oss-cn-shanghai.aliyuncs.com/study-pic/202312031052779.png)\n\n**WGestures**:一款可以让鼠标开挂的软件。\n\n![image-20231203105505935](https://pic-es.oss-cn-shanghai.aliyuncs.com/study-pic/202312031055956.png)\n\n可以根据自己的习惯去设定手势。比如我的：用鼠标右键向右滑=4个指头向右滑，向左滑=4个指头向左滑，右键画一个错号就是关闭当前页，以及最大化最小化看自己习惯去设置，我更多使用的是在开发工具里给一些复杂的快捷键去设定手势，比如设定debug的时候需要评估表达式，回退，前进等操作手势可以非常高效得提高生产效率。\n\n所以提高生产力有时候也可以从解放一只手做起，把操作都优化到一个指头上，是不是很优雅哈哈。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1630821133601288193/6WM9aDMC-可爱002.jpg",
        "language": null,
        "viewNum": 15,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1630821133601288193",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-03T03:24:19.000+00:00",
        "updateTime": "2023-12-04T08:36:44.000+00:00",
        "user": {
          "id": "1630821133601288193",
          "planetCode": "9414",
          "userName": "小糖豆",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1630821133601288193/8ZwBYNWO-aaaa.jpg",
          "gender": 1,
          "userProfile": "一名刚毕业没多久的后端开发者，希望可以在这个圈子学到更多知识。",
          "userRole": "vip",
          "interests": [
            "后端",
            "书籍"
          ],
          "place": "北京",
          "birthday": "2000-12-16",
          "school": "",
          "major": "软件工程",
          "education": "一本",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 1,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/hynzdc",
          "blog": "https://www.sweetmore.cn/",
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-06-04T14:02:41.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-01T06:43:52.000+00:00",
          "updateTime": "2023-11-29T07:30:37.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730896476969758722",
        "title": "链表高频面试题",
        "description": "链表高频面试题",
        "content": "## 1 链表相交\n\n### 题目描述\n\n[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**示例 1：**\n\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n\n```java\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n\n\n### 解法一：哈希表\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    HashSet<ListNode> hashSet = new HashSet<>();\n\n    while (headA != null)\n    {\n        hashSet.add(headA);\n        headA = headA.next;\n    }\n\n    while (headB != null)\n    {\n        if(hashSet.contains(headB))\n            return headB;\n\n        headB = headB.next;\n    }\n\n    return null;\n}\n```\n\n### 解法二：栈\n\n```java\npublic static ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    ArrayDeque<ListNode> stackA = new ArrayDeque<>();\n    ArrayDeque<ListNode> stackB = new ArrayDeque<>();\n\n    //两个链表分别入不同的栈\n    while (headA != null)\n    {\n        stackA.push(headA);\n        headA = headA.next;\n    }\n    while (headB != null)\n    {\n        stackB.push(headB);\n        headB = headB.next;\n    }\n\n\n    ListNode intersectionNode = null;   //要跟着两链表相同的结点\n\n    //从后往前理解（栈先进后出的特性）\n    while (!stackA.isEmpty() && !stackB.isEmpty())\n    {\n        if (stackA.peek().val == stackB.peek().val)\n        {\n            intersectionNode = stackA.pop();\n            stackB.pop();\n        }\n        else\n            break;  //两链表开始分叉，intersectionNode也指向了第一个交汇结点\n    }\n\n    return intersectionNode;\n```\n\n### 解法三：换表双指针\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    //排除掉不好统一处理的空链表情况\n    if(headA == null || headB == null)\n        return null;\n\n    ListNode p = headA;\n    ListNode q = headB;\n\n    while(p != q)\n    {\n        p = p.next;\n        q = q.next;\n\n        if(p != q)\n        {\n            //自己的链表遍历完了就跳到另一个链表一直遍历下去，直到相遇，或者都等于null\n           if(p == null)\n               p = headB;\n           if(q == null)\n               q = headA;\n        }\n\n    }\n    //return得放在外面，否则编译报错：无返回语句\n    return p;\n}\n```\n\n### 解法四：差和双指针\n\n或称快慢指针。长链表的指针比短链表的指针先走|len1 - len2|步，然后同步移动，指向同一结点时返回答案\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    if(headA == null || headB == null)\n        return null;\n\n    //获取headA的表长\n   ListNode p = headA;\n   int len_A = 0;\n   while (p != null)\n   {\n       len_A++;\n       p = p.next;\n   }\n\n    //获取headB的表长\n    ListNode q = headB;\n    int len_B = 0;\n    while (q != null)\n    {\n        len_B++;\n        q = q.next;\n    }\n\n    int diff = Math.abs(len_A - len_B);\n\n    if(len_A < len_B)   //headB先走\n    {\n        while (diff != 0)\n        {\n            headB = headB.next;\n            diff--;\n        }\n    }\n    else if(len_A > len_B)   //headA先走\n    {\n        while (diff != 0)\n        {\n            headA = headA.next;\n            diff--;\n        }\n    }\n\n    while (headA != headB)\n    {\n        headA = headA.next;\n        headB = headB.next;\n    }\n\n    return headA;\n}\n```\n\n\n\n## 2 回文链表\n\n### 题目描述\n\n[234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/description/)\n\n给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)\n\n```java\n输入：head = [1,2,2,1]\n输出：true\n```\n\n\n\n### 解法一：值复制\n\n虽然这么做简单易懂，但面试手撕算法题时不推荐，因为会被视为逃避链表，失去了考验价值\n\n```java\n    public boolean isPalindrome(ListNode head) \n    {\n        //将每一个结点的值复制到ArrayList。\n        ArrayList<Integer> vals = new ArrayList<>();\n\n        while(head != null)\n        {\n            vals.add(head.val);\n            head = head.next;\n        }\n\n        //进行回文判断\n        int left = 0;\n        int right = vals.size() - 1;\n\n        while(left < right)\n        {\n            if(vals.get(left).equals(vals.get(right)) == false)\n                return false;\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n```\n\n\n\n### 解法二：快慢指针+反转链表\n\n```java\n//寻找中间结点。若链表有奇数个节点，则中间的节点应该看作是前半部分。\n    private ListNode endOfFirstHalf(ListNode head)\n    {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next != null && fast.next.next != null)\n        {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n\n    //反转链表\n    private ListNode reverseList(ListNode head)\n    {\n        ListNode pre = null;\n        ListNode suc = head;\n\n        while(head != null)\n        {\n            suc = head.next;\n            head.next = pre;     \n            pre = head;     \n            head = suc;     \n        }\n\n        return pre;\n    }\n\n    public boolean isPalindrome(ListNode head) \n    {\n        if(head == null)\n            return true;\n        \n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        //判断是否是回文链表\n        ListNode p = head;\n        ListNode q = secondHalfStart;\n        boolean ans = true;\n        while(q != null)\n        {\n            if(p.val != q.val)\n            {\n                ans = false;\n                break;\n            }\n\n            p = p.next;\n            q = q.next;      \n        }\n\n        //恢复后半部分链表\n        firstHalfEnd.next = reverseList(secondHalfStart);\n\n        //返回判断结果\n        return ans;\n    }\n```\n\n\n\n### 解法三：栈\n\n```java\npublic static boolean isPalindrome(ListNode head)\n    {\n        ArrayDeque<ListNode> stack = new ArrayDeque<>();\n\n        ListNode t = head;\n        while (t != null)\n        {\n            stack.push(t);\n            t = t.next;\n        }\n\n        while (head != null)\n        {\n            if(stack.pop().val != head.val)\n                return false;\n            head = head.next;\n        }\n\n        return true;\n    }\n```\n\n\n\n## 3 合并链表\n\n### 3.1 合并两个有序链表\n\n#### 题目描述\n\n[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n\n```java\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) \n    {\n        if(list1 == null)\n            return list2;\n        if(list2 == null)\n            return list1;\n\n        ListNode p = list1; //新的引用\n        ListNode q = list2;\n        ListNode head = new ListNode(0 , null); //新链表的头结点\n        ListNode r = head;\n\n        while(p != null  && q != null)\n        {\n            //一次只处理一个结点\n            if(p.val <= q.val)  \n            {\n                r.next = p;\n                p = p.next;\n            }\n            else\n            {\n                r.next = q;\n                q = q.next;\n            }\n\n            r = r.next; //先链接，后更新\n        }\n\n        if(p == null)\n            r.next = q;\n        if(q == null)\n            r.next = p;\n\n        return head.next;\n    }\n```\n\n\n\n### 3.2 合并K个有序链表\n\n在3.1的基础上\n\n```java\npublic ListNode mergeKLists(ListNode[] lists) \n{\n\tListNode res = null;\n    //逐一链接\n\tfor (ListNode list: lists)\n\t\tres = mergeTwoLists(res,lists);\n\t\n    return res;\n}\n```\n\n\n\n### 3.3 嫁接两个链表\n\n#### 题目描述\n\n[1669. 合并两个链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-in-between-linked-lists/description/)\n\n给你两个链表 `list1` 和 `list2` ，它们包含的元素分别为 `n` 个和 `m` 个。\n\n请你将 `list1` 中下标从 `a` 到 `b` 的全部节点都删除，并将`list2` 接在被删除节点的位置。\n\n下图中蓝色边和节点展示了操作后的结果：\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png)\n\n请你返回结果链表的头指针。\n\n**示例 1：**\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png)\n\n```java\n输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n输出：[0,1,2,1000000,1000001,1000002,5]\n解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。\n```\n\n\n\n#### 解\n\n```java\npublic ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\n    ListNode pre = list1;\n    ListNode post = list1;\n    int i = 0;\n    int j = 0;\n\n    //定位待删除部分的前驱和后继\n    while (i < a - 1) { //用<号，i=a-2时最后一次进入循环，退出循环时pre刚好指向下标为a-1的结点\n        pre = pre.next;\n        i++;\n    }\n\n    while (j < b + 1) {\n        post = post.next;\n        j++;\n    }\n\n    //定位list2的尾结点\n    ListNode r = list2;\n    while (r.next != null)\n        r = r.next;\n\n    //连接\n    pre.next = list2;\n    r.next = post;\n\n    return list1;\n}\n```\n\n\n\n## 4 双指针专题\n\n### 4.1 寻找中间结点\n\n#### 题目描述\n\n[876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/description/)\n\n给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n\n```java\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n```\n\n\n\n#### 解\n\n```java\n    public ListNode middleNode(ListNode head)\n    {\n        ListNode p = head;\n        ListNode q = head;\n\n    \t//p每次走两步，q每次走一步\n    \t//p走到最后的NULL时,q恰好到中间\n    \t//偶数个结点的话，q则指向第二个中间结点\n    \twhile(p !=null && p.next != null)\n    \t{\n        \tp = p.next.next;\n        \tq = q.next;\n    \t} \n\n    \treturn q;\n    }\n```\n\n\n\n### 4.2 寻找倒数第K个元素\n\n#### 解法一：两次遍历\n\n第一次遍历得到链表长度，第二次遍历找倒数K个元素\n\n#### 解法二：快慢指针\n\n两种模板\n\n```java\npublic ListNode getNthFromEnd(ListNode head, int n)\n{\n    ListNode fast = head;\n    ListNode slow = head;\n\n    while (fast != null)\n        {\n            if(n <= 0)   \n            \tslow = slow.next; \n            \n        \tfast = fast.next;\n        \tn--;\n        }\n    \n    return slow;\n}\n```\n\n```java\npublic ListNode getKthFromEnd(ListNode head, int k)\n    {\n    ListNode fast = head;\n    ListNode slow = head;\n\n    while(fast != null && k > 0)\n    {\n        fast = fast.next;\n        k--;\n    }\n    \n    while(fast != null)\n    {\n        fast = fast.next;\n        slow = slow.next; \n    }\n    \n    return slow;\n}\n```\n\n\n\n### 4.3 旋转链表\n\n#### 题目描述\n\n[61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/description/)\n\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n\n```java\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\n\n```java\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode rotateRight(ListNode head, int k)\n{\n    if (head == null || k == 0)\n        return head;\n\n    //获取链表长度\n    ListNode t = head;\n    int length = 0;\n    while (t != null)\n    {\n        length++;\n        t = t.next;\n    }\n\n    int K = k % length; //最小旋转次数\n    if(K == 0)\n        return head;\n    //寻找倒数第K个结点的前驱\n    ListNode fast = head;\n    ListNode slow = head;   //倒数第K个结点的前驱\n    while (fast.next != null)   //fast需要停留在最后一个结点\n    {\n        if(K <= 0)\n            slow = slow.next;\n\n        fast = fast.next;\n        K--;\n    }\n\n    ListNode res = slow.next;   //旋转过后的链表的头结点为倒数第K个结点\n    slow.next = null;  //断开前驱与倒数第K个结点的链接，避免成环。即slow作为新链表的尾结点\n    fast.next = head;   //原尾结点连接原头结点，\"旋转\"完成\n\n    return res;\n}\n```\n\n\n\n## 5 删除链表元素\n\n### 5.1 删除特点结点\n\n#### 题目描述\n\n[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/description/)\n\n给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)\n\n```java\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n```\n\n\n\n#### 解法一：单独处理头结点\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution \n{\n    public ListNode removeElements(ListNode head, int val) \n    {\n        //val出现在头结点\n        while(head != null && head.val == val)  \n            head = head.next;\n    \n         if(head == null)\n            return head;  //直接解决全部都是val的情况\n\n\n    ListNode p = head;\n\n    while(p != null && p.next != null)  //常规情况\n    {\n        if(p.next.val == val)\n        {\n            p.next = p.next.next;  \n        }\n        else\n        {\n            p = p.next;\n        }\n    }\n\n    return head;\n    }\n}\n```\n\n\n\n#### 解法二：虚拟结点\n\n```java\npublic ListNode removeElements(ListNode head, int val)\n{\n    ListNode dummyNode = new ListNode(-1);\n    dummyNode.next = head;  //为将头结点当作普通结点处理\n    ListNode cur = dummyNode;\n\n    while (cur.next != null)    //如果尾结点也是要删除的结点，那它也能被“跳过”。要时刻谨记.next存的是下一结点的地址，不是一根线\n    {\n        if(cur.next.val == val)\n            cur.next = cur.next.next;   //cur所指结点的后继变了，且cur仍然指向当前结点\n        else\n            cur = cur.next; //下一个结点的值（终于）不重复时，cur才指向下一个结点\n    }\n\n    return dummyNode.next;\n}\n```\n\n\n\n### 5.2 删除倒数第n个结点\n\n#### 题目描述\n\n[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n```java\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n\n\n\n#### 解法一：两次遍历\n\n```c\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n)\n{\n    //计算链表长度\n    struct ListNode* fast = head;\n    struct ListNode* slow = head;\n\n    while(fast)\n    {\n        if(n < 0)\n            slow = slow->next; //慢指针开始与快指针同步移动\n        fast = fast->next;\n        n--;\n    }\n\n    if(n == 0)  //要删除的是头结点，返回其余结点\n        return head->next;\n\n    slow->next = slow ->next->next; //删除指定结点\n\n    return head;      \n}\n\n```\n\n\n\n#### 解法二：快慢指针一次遍历\n\n```java\npublic ListNode removeNthFromEnd(ListNode head, int n)\n    {\n         //计算链表长度\n    \tListNode fast = head;\n    \tListNode slow = head;\n\n    \twhile(fast != null)\n    \t{\n        \tif(n < 0)\t//慢指针开始与快指针同步移动，最终slow会指向待删除结点的前驱\n            \tslow = slow.next; \n        \tfast = fast.next;\n        \tn--;\n    \t}\n\n    \tif(n == 0)  //若删除的是头结点，则返回其余结点\n        \treturn head.next;\n\n    \tslow.next = slow.next.next; //删除指定结点\n\n    \treturn head; \n    }\n```\n\n\n\n### 5.3 重复元素保留一个\n\n#### 题目描述\n\n[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)\n\n给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n\n```java\n输入：head = [1,1,2]\n输出：[1,2]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n\n```java\n输入：head = [1,1,2,3,3]\n输出：[1,2,3]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode deleteDuplicates(ListNode head)\n{\n    if (head == null)\n        return null;\n\n    ListNode cur = head;\n\n    while (cur.next != null)\n    {\n        if(cur.val == cur.next.val)\n            cur.next = cur.next.next;\n        else\n            cur = cur.next;\n    }\n\n    return head;\n}\n```\n\n\n\n### 5.4 重复元素一个都不要\n\n#### 题目描述\n\n[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/)\n\n给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n\n```java\n输入：head = [1,2,3,3,4,4,5]\n输出：[1,2,5]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n\n```java\n输入：head = [1,1,1,2,3]\n输出：[2,3]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode deleteDuplicates(ListNode head)\n{\n    ListNode dummyNode = new ListNode(0, head);\n    ListNode cur = dummyNode;\n\n    while (cur.next != null && cur.next.next != null)\n    {\n        if (cur.next.val == cur.next.next.val)\n        {\n            //用一个小循环删除这部分重复元素\n            int x = cur.next.val;\n            while (cur.next != null && cur.next.val == x)\n            {\n                cur.next = cur.next.next;   //把指针域也画出来才容易理解\n            }\n        }\n        else    //如if被执行，则cur不会往后移动，这使得两个while可以合力一口气删完如[2,2,3,3,5,5,5]的重复部分，然后cur才需要往后移动\n            cur = cur.next;\n    }\n\n    return dummyNode.next;\n}\n```",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1703618142791659522/Ysz19b47-dian ni.jpg",
        "language": null,
        "viewNum": 9,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1703618142791659522",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-02T10:27:33.000+00:00",
        "updateTime": "2023-12-04T09:47:12.000+00:00",
        "user": {
          "id": "1703618142791659522",
          "planetCode": "27324",
          "userName": "陈星泽",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1703618142791659522/5K8Myn4Z-1684984658778.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-09-18T03:36:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-09-18T03:53:11.000+00:00",
          "updateTime": "2023-09-21T04:58:45.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730148626065387521",
        "title": "Mybatis整合多数据源",
        "description": "有时候我们需要查询来自多个库表的数据内容，但是又不想起多个服务，可以业务需要这些数据那该怎么办呢？那么其实Mybatis 是支持整合多数据源，并随时进行切换。",
        "content": "## 背景\n\n有时候我们需要查询来自多个库表的数据内容，但是又不想起多个服务，可以业务需要这些数据那该怎么办呢？那么其实Mybatis 是支持整合多数据源，并随时进行切换。\n\n## 解决\n\n### 引入依赖\n\n首先引入`dynamic-datasource-spring-boot-starter`依赖\n\n```xml\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>dynamic-datasource-spring-boot-starter</artifactId>\n  <version>${version}</version><!--版本号-->\n</dependency>\n```\n\n### 配置文件\n\n```yaml\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n    map-underscore-to-camel-case: true\n  mapper-locations: mapper/*.xml\n\nserver:\n  port: 8989\n\nspring:\n  datasource:\n    dynamic:\n      primary: master\n      strict: false\n      datasource:\n        master:\n          url: jdbc:mysql://localhost:3306/yuapi?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false\n          username: root\n          password: root\n          driver-class-name: com.mysql.cj.jdbc.Driver\n        slave_1:\n          url: jdbc:mysql://localhost:3306/db_email?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false\n          username: root\n          password: root\n          driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n#### 配置方式\n\n```yaml\n# 多主多从                      纯粹多库（记得设置primary）                   混合配置\nspring:                               spring:                               spring:\n  datasource:                           datasource:                           datasource:\n    dynamic:                              dynamic:                              dynamic:\n      datasource:                           datasource:                           datasource:\n        master_1:                             mysql:                                master:\n        master_2:                             oracle:                               slave_1:\n        slave_1:                              sqlserver:                            slave_2:\n        slave_2:                              postgresql:                           oracle_1:\n        slave_3:                              h2:                                   oracle_2:\n\n```\n\n\n\n### 通过注解切换数据源\n\n可以通过`@DS`注解进行数据源切换\n\n```java\n@Service\n@DS(\"master\")\npublic class InterfaceInfoServiceImpl extends ServiceImpl<InterfaceInfoMapper, InterfaceInfo> implements InterfaceInfoService {\n}\n```\n\n```java\n@Service\n@DS(\"slave_1\")\npublic class TEmailServiceImpl extends ServiceImpl<TEmailMapper, TEmail> implements TEmailService {\n}\n```\n\n注解的内容对应配置里的名称。\n\n## 约定\n\n1. 本框架只做 切换数据源 这件核心的事情，并不限制你的具体操作，切换了数据源可以做任何CRUD。\n2. 配置文件所有以下划线 _ 分割的数据源 首部 即为组的名称，相同组名称的数据源会放在一个组下。\n3. 切换数据源可以是组名，也可以是具体数据源名称。组名则切换时采用负载均衡算法切换。\n4. .默认的数据源名称为 master ，你可以通过 spring.datasource.dynamic.primary 修改。\n5. 方法上的注解优先于类上注解。\n6. DS支持继承抽象类上的DS，暂不支持继承接口上的DS，在方法上面标记优先级高于在类上标记。\n\n> 注意这个原理也是基于AOP,所以在一个方法内是不可以切换数据源的。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1630821133601288193/dmzjP4Xn-可爱001.jpg",
        "language": null,
        "viewNum": 19,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1630821133601288193",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-30T08:55:51.000+00:00",
        "updateTime": "2023-12-04T06:57:04.000+00:00",
        "user": {
          "id": "1630821133601288193",
          "planetCode": "9414",
          "userName": "小糖豆",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1630821133601288193/8ZwBYNWO-aaaa.jpg",
          "gender": 1,
          "userProfile": "一名刚毕业没多久的后端开发者，希望可以在这个圈子学到更多知识。",
          "userRole": "vip",
          "interests": [
            "后端",
            "书籍"
          ],
          "place": "北京",
          "birthday": "2000-12-16",
          "school": "",
          "major": "软件工程",
          "education": "一本",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 1,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/hynzdc",
          "blog": "https://www.sweetmore.cn/",
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-06-04T14:02:41.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-01T06:43:52.000+00:00",
          "updateTime": "2023-11-29T07:30:37.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730019669194174466",
        "title": "SQL还能这么写？",
        "description": "十种SQL的语法",
        "content": "## SQL语法\n\n### 一、ORDER BY FIELD()自定义排序逻辑\n\nORDER BY FIELD(str,str1,...) 自定义排序sql如下：\n\n```sql\nSELECT * from order_diy ORDER BY FIELD(title,'九阴真经', '降龙十八掌','九阴白骨爪','双手互博','桃花岛主','全真内功心法','蛤蟆功','销魂掌','灵白山少主');\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/4TzuXuKG-image.png)\n\n\n\n### 二、CASE表达式\n\n假如我们想在 order_diy 表加一列 level 列，根据money 判断大于60就是高级，大于30就是中级，其余显示低级，sql 如下：\n\n```sql\nSELECT *, \ncase when money > 60 then '高级' \nwhen money > 30 then '中级' \nelse '低级' END level \nfrom order_diy;\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/QPBUIM5h-image.png)\n\n\n### 三、EXISTS用法\n\n可知 exists 后面是跟着一个子查询语句，它的作用是**根据主查询的数据，每一行都放到子查询中做条件验证，根据验证结果（TRUE 或者 FALSE），TRUE的话该行数据就会保留**，下面用 emp 表和 dept 表进行举例，表结构以及数据展示：计入我们现在想找到 emp 表中 dept_name 与 dept表 中 dept_name 对应不上员工数据，sql 如下：\n\n```sql\nSELECT * from emp e where exists (\nSELECT * from dept p where e.dept_id = p.dept_id \nand e.dept_name != p.dept_name\n)\n```\n\n### 四、GROUP CONCAT(expr)组连接函数\n\n**GROUP_CONCAT(expr)** 组连接函数可以返回分组后指定字段的字符串连接形式，并且可以指定排序逻辑，以及连接字符串，默认为英文逗号连接。这里继续用 order_diy 表举例：sql 如下：\n\n```sql\nSELECT name, GROUP_CONCAT(title ORDER BY id desc  SEPARATOR '-') \nfrom order_diy GROUP BY name ORDER BY NULL;\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/M8jS3B8Y-image.png)\n\n\n### 五、自连接查询\n\ntree 表中通过 pid 字段与 id 字段进行父子关联，假如现在有一个需求，我们想按照父子层级将 tree 表数据转换成 `一级职位 二级职位 三级职位` 三个列名进行展示，sql 如下：\n\n```sql\nSELECT t1.job_name '一级职位', t2.job_name '二级职位', t3.job_name '三级职位' \nfrom tree t1 join tree t2 on t1.id = t2.pid left join tree t3 on t2.id = t3.pid \nwhere t1.pid = 0;\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/YWtSAL7p-image.png)\n\n\n### 六、更新emp表和dept表关联数据\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/s0HuySGC-image.png)\n\n可以看到上述 emp 表中 jack 的部门名称与 dept 表实际不符合，现在我们想将 jack 的部门名称更新成 dept 表的正确数据，sql 如下：\n\n```sql\nupdate emp, dept set emp.dept_name = dept.dept_name\nwhere emp.dept_id = dept.dept_id;\n```\n\n### 七、ORDER BY空值NULL排序\n\nORDER BY 字句中可以跟我们要排序的字段名称，但是当字段中存在 null 值时，会对我们的排序结果造成影响。我们可以通过 **ORDER BY IF(ISNULL(title), 1, 0)** 语法将 null 值转换成0或1，来达到将 null 值放到前面还是后面进行排序的效果。这里继续用 order_diy 表举例，sql 如下：\n\n```sql\nSELECT * FROM order_diy ORDER BY  IF(ISNULL(title), 0, 1), money;\n```\n\n### 八、with rollup分组统计数据的基础上再进行统计汇总\n\nMySql 中可以使用 with rollup 在分组统计数据的基础上再进行统计汇总，即用来得到 group by 的汇总信息。这里继续用order_diy 表举例，sql 如下：\n\n```sql\nSELECT name, SUM(money) as money \nFROM order_diy GROUP BY name WITH ROLLUP;\n复制代码\n```\n\n查询结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/QlZ1AXen-image.png)\n\n\n可以看到通过 **GROUP BY name WITH ROLLUP** 语句，查询结果最后一列显示了分组统计的汇总结果。但是 name 字段最后显示为 null，我们可以通过 `coalesce(val1, val2, ...)` 函数，这个函数会返回参数列表中的第一个非空参数。\n\n### 九、with as 提取临时表别名\n\n如果一整句查询中**多个子查询都需要使用同一个子查询**的结果，那么就可以用 with as，将共用的子查询提取出来，加个别名。后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用。这里继续用 order_diy 表举例，这里使用 with as 给出 sql 如下：\n\n```sql\n-- 使用 with as\nwith t1 as (SELECT * from order_diy where money > 30),\nt2 as (SELECT * from order_diy where money > 60)\nSELECT * from t1 \nwhere t1.id not in (SELECT id from  t2) and t1.name = '周伯通';\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Ch4NIUhN-image.png)\n\n### 十、存在就更新，不存在就插入\n\nMySql 中通过**on duplicate key update**语法来实现存在就更新，不存在就插入的逻辑。插入或者更新时，它会根据表中主键索引或者唯一索引进行判断，如果主键索引或者唯一索引有冲突，就会执行**on duplicate key update**后面的赋值语句。 这里通过 news 表举例，表结构和说数据展示，其中 news_code 字段有唯一索引：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Bcu6T57I-image.png)\n 添加sql：\n\n```sql\n-- 第一次执行添加语句\nINSERT INTO `news` (`news_title`, `news_auth`, `news_code`) \nVALUES ('新闻3', '小花', 'wx-0003') \non duplicate key update news_title = '新闻3';\n-- 第二次执行修改语句\nINSERT INTO `news` (`news_title`, `news_auth`, `news_code`) \nVALUES ('新闻4', '小花', 'wx-0003') \non duplicate key update news_title = '新闻4';\n```",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 19,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1612254411675926529",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-30T00:23:25.000+00:00",
        "updateTime": "2023-12-04T06:58:04.000+00:00",
        "user": {
          "id": "1612254411675926529",
          "planetCode": "12852",
          "userName": "聪ζ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-09T22:01:57.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-09T01:06:20.000+00:00",
          "updateTime": "2023-10-30T12:03:51.000+00:00"
        },
        "tags": [
          "文章",
          "MySQL"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1729868762959704065",
        "title": "foreach循环中remove操作 （什么是fail-fast）",
        "description": "Java中有个fail-fast错误检测机制，一旦检测到可能发生错误，就会立马抛出异常，程序不能继续执行下去。",
        "content": "先来看看下面的三段代码，你觉得有哪几个会报错，那几个会正确输出list\n\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        for(String str:list){\n            if(\"2\".equals(str)){\n                list.remove(str);\n            }\n        }\n        System.out.println(list);\n```\n\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for(String str:list){\n            if(\"2\".equals(str)){\n                list.remove(str);\n            }\n        }\n        System.out.println(list);\n```\n\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"1\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for(String str:list){\n            if(\"2\".equals(str)){\n                list.remove(str);\n            }\n        }\n        System.out.println(list);\n    }\n```\n先公布答案\n上面上段代码执行结果分别是：\n```[2]```\n```Exception in thread \"main\" java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:861)\n\tat com.xmz.test.Test.main(Test.java:16)\n```\n```[1, 3]```\n\n## 先说正确规范\n在阿里巴巴手册中明确规定了，不要在foreach中使用```remove\\add```操作。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d02443d2c2e7431b902327d49e29b4d6.png)\n## 【问题】为什么上面代码1，3没问题？2会抛异常\n**异常的原因**：\n\t因为增强for循环是根据迭代器遍历的，在循环中修改集合大小，会导致迭代器中的数据不一致，可能导致错误。\n\tJava中有个fail-fast错误检测机制，一旦检测到可能发生错误，就会立马抛出异常，程序不能继续执行下去。\n**1和3为什么不报异常？**\n\t因为在某些特殊情况下，```list.remove(str)```可以在不触发```fail-fast```机制的情况下删除元素。\n\t例如在上面的第一、三两个代码中，我们删除的是列表中的倒数第二个元素，那么就不会抛出异常，因为这种情况下，删除了元素，同时也改变了列表的大小，使得列表的大小和当前的cursor的大小一样，因此就不会执行```checkForComodification()```方法，也就不会抛出异常。\n\n## 【方案】怎么在集合中正确使用```remove\\add```操作\n### 方案一、使用普通for循环进行操作\n```java\n List<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for (int i = 0; i < list.size(); i++) {\n            if(\"2\".equals(list.get(i))){\n                list.remove(list.get(i));\n            }\n        }\n        System.out.println(list);\n```\n但是这种方案在remove的时候，会存在漏删的情况。\n输出结果：```[2, 3]```\n\n### 方案二、使用Iterator提供的remove方法。\n这也就是在阿里巴巴开发手册中的方法\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        Iterator<String> iterator = list.iterator();\n        while (iterator.hasNext()){\n            String str = iterator.next();\n            if(\"2\".equals(str)){\n                iterator.remove();\n            }\n        }\n        System.out.println(list);\n```\n输出结果：```[3]```\n这是最正确的方案\n\n### 方案三、使用filter过滤\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        list = list.stream().filter(str -> !\"2\".equals(str)).collect(Collectors.toList());\n        System.out.println(list);\n```\n输出结果：```[3]```\n\n### 方案四、使用增强for循环也可以，但是每次要break\n如果这个集合中只有一个我们要删除的元素，就可以使用这种方案，像set集合，如果list集合里面有多个要删除的元素，最终只能成功删除第一个\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"1\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for(String str:list){\n            if(\"1\".equals(str)){\n                list.remove(str);\n                break;\n            }\n        }\n        System.out.println(list);\n```\n输出结果：```[2, 3]```\n\n### 方案五、使用fail-fast集合类\n在Java中，有一些fail-fast机制的集合类。这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。\n由于在迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能背迭代器检测到。\n\n```java\n        ConcurrentLinkedDeque<String> concurrentLinkedDeque = new ConcurrentLinkedDeque<>();\n        concurrentLinkedDeque.add(\"2\");\n        concurrentLinkedDeque.add(\"2\");\n        concurrentLinkedDeque.add(\"3\");\n        for(String str:concurrentLinkedDeque){\n            if(\"2\".equals(str)){\n                concurrentLinkedDeque.remove(str);\n            }\n        }\n        System.out.println(concurrentLinkedDeque);\n```\n\n### 参考文章\n[参考文章：什么是fail-fast](https://www.cnblogs.com/54chensongxia/p/12470446.html)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627708957655060481",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-29T14:23:47.000+00:00",
        "updateTime": "2023-12-04T09:47:53.000+00:00",
        "user": {
          "id": "1627708957655060481",
          "planetCode": "2020",
          "userName": "onepiece",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1627708957655060481/LJ6EWTRq-595942610193259787.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-21T22:31:28.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-20T16:37:11.000+00:00",
          "updateTime": "2023-08-08T13:27:58.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1729852969043750914",
        "title": "MySQL字符串日期格式转换",
        "description": "关于MySQL字符串转日期格式的那些事",
        "content": "### 起因\n\n需要将Oracle中的数据导到MySQL中\n\n### 阻碍\n\n在Oracle导出数据时，发现导出的SQL脚本中的日期转换是`to_date('28-11-2023 14:15:17', 'dd-mm-yyyy hh24:mi:ss')`的形式，但MySQL并不认识这个格式转换函数，此时需要将Oracle中这个日期转换函数替换成MySQL中的日期格式转换函数才能在MySQL中执行导出的脚本，那么在MySQL中日期如何转换呢？\n\n### 分析\n\n在`to_date('28-11-2023 14:15:17', 'dd-mm-yyyy hh24:mi:ss')`中，是要将给定的字符串`28-11-2023 14:15:17`按照`dd-mm-yyyy hh24:mi:ss`的格式转换成日期，那么我们也需要在MySQL找到一个函数能够将指定的字符串按照一定的格式转换成日期。\n\n### 解决\n\n在MySQL中可以使用`str_to_date(str,format)`这个函数来实现将字符串按照时间格式转换成日期。那么对于Oracle中的`to_date('28-11-2023 14:15:17', 'dd-mm-yyyy hh24:mi:ss')`可以修改成`str_to_date('28-11-2023 14:15:17', '%d-%m-%Y %H:%i:%s')`，替换后就可以在MySQL执行进行日期转换了。\n\n验证，结果如下：\n\n![1701263190955.png](https://pic.code-nav.cn/post_picture/1632761346305089537/EPkQMXrk-1701263190955.png)\n\n### 总结\n\n1. Oracle中字符串转日期：`to_date('28-11-2023 14:15:17', 'dd-mm-yyyy hh24:mi:ss')`\n2. MySQL中字符串转日期：`str_to_date('28-11-2023 14:15:17', '%d-%m-%Y %H:%i:%s')`\n3. MySQL常见时间格式化：（与字符串中的对应使用）\n   1. %Y： 年份，四位数字\n   2. %m：月份，两位数字\n   3. %d： 日期，两位数字\n   4. %H：小时（24小时制），两位数字\n   5. %i： 分钟，两位数字\n   6. %s： 秒，两位数字\n4. 扩展：MySQL中如果想将日期转换成字符串可以使用`date_format(date,format)`\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 5,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1632761346305089537",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-29T13:21:01.000+00:00",
        "updateTime": "2023-12-01T00:29:01.000+00:00",
        "user": {
          "id": "1632761346305089537",
          "planetCode": "18875",
          "userName": "tree",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1632761346305089537/y7rrvMgi-可达鸭头像.png",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "面试题",
            "面试题挑战",
            "简历",
            "面试",
            "开源",
            "软件"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-03-09T04:58:34.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-06T15:13:34.000+00:00",
          "updateTime": "2023-04-10T11:45:33.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1729816929826369537",
        "title": "为什么我强烈建议大家找实习？",
        "description": null,
        "content": "大家好，我是鱼皮，前两天**编程导航**的鱼友向我提了一个关于学习规划的问题，蛮有代表性的，给大家分享一下。\n\n\n\n## 鱼友提问\n\n鱼皮你好，我是一位大二、软件工程专业的同学，最近在学设计模式和操作系统，项目已经做完了伙伴匹配系统、智能 BI、和聚合搜索项目（正在上线），想问几个问题：\n\n1）之前你说过寒假实习在十一月就可以开始找了，现在我有必要去找吗？还是继续按照学习路线学习，因为我感觉自己还有很多东西没学。\n\n2）我想知道考研和本科进大厂是能两手抓的吗？就我目前的情况来看是无法向你一样保研了，只能选考研做退路。目前我的目标还是优先找工作，找不到再读研，这里我有个疑惑的点，就是到了可以准备考研的时候我应该是无法确定自己是否能找到好工作的，真到了那个时候我该怎么做呢？\n\n\n\n## 鱼皮回答\n\n### 1、一定要去实习\n\n第一个问题是非常经典的，可以归纳为 “什么时候去找实习？有没有必要去实习？”\n\n我的建议是这样的：\n\n1）衡量是否该去找实习的标准：简单来说，就是你是否具备干活（甚至是打杂）的能力。如果你现在什么技术都没学，连 Java 基础语法都敲不熟练，那就别想着去找实习了，能让什么技术都不会的同学去实习的公司大概率也不会给你安排对技术有提升的工作。\n\n一般情况下，我是建议目前主流开发框架（比如后端 Spring Boot、前端 Vue）已经学完，并且已经完成了 2 - 3 个项目，可以写出一份完整的简历后，再去找实习。\n\n> 当然，如果你有其他特殊的牛 X 经历，或者学历特别好，当我没说。因为从你的经历中，也许已经证明了你的能力。\n\n\n\n2）强烈建议大家尽快去找实习。提前找实习的好处太多了，不仅能检验自己的技术水平和实践能力是否过关，还能提前增加自己的求职面试经验，哪怕没通过也是有收获的。\n\n而如果成功找到实习，可以提前接触工作的环境，判断自己是否适合某个工作，从而帮助自己做出未来规划。\n\n所以当你达到上述标准后，就多关注下求职信息，建议去找寒假实习或日常实习，或者把它当做自己的目标，投递下试试也不亏。\n\n\n\n### 2、考研和本科就业能否两手抓？\n\n当你问出这个问题的时候，我就默认你不打算 all in 考研（考不上就接着考）了。\n\n所以我的答案是 “能”，并且建议两手抓，给自己多一条退路。\n\n大学期间，建议直到大三寒假前，把更多精力放在学习技术做项目、提升实践能力上，并且趁早找一份实习帮助自己切身体验下外面的企业实际工作氛围，才有助于帮助自己做出未来的规划和决策。\n\n我当时也非常纠结是读研还是就业，有人劝我直接工作、也有人劝我读研，各占一半，但大家都只是站在不同的角度思考罢了，没有人知道到底什么选择最适合你。所以不要让别人帮你选择，路应该是自己走出来的。\n\n考研全力准备一年是足够了的，过早准备学了就忘、性价比不高，而且万一失利后就业也会更难了。所以建议在那之前，好好学技术并且丰富下自己的实践经历吧~\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/iTA869lx-SCR-20231129-qizj.jpeg",
        "language": null,
        "viewNum": 25,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-29T10:57:49.000+00:00",
        "updateTime": "2023-12-04T08:57:04.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 2985,
          "coin": 170,
          "followeeNum": 1263,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-12-02T07:33:16.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "231",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "29"
  },
  "message": "ok"
}